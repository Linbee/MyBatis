Mybatis学习笔记
持久层框架 数据库交互
Hibernate 全自动全映射ORM(Object Relation Mapping)框架 旨在消除sql HQL编写sql语句
Mybatis 半自动轻量级框架 sql与java编码分离，sql受开发人员控制

在github下载mybatis

http://www.mybatis.org/mybatis-3 文档地址
https://github.com/mybatis/mybatis-3/releases jar包下载地址
https://mvnrepository.com/artifact/mysql/mysql-connector-java jdbc 下载

课外发现
source folder 和 folder 的区别
source folder 所有Java源文件都会被时时编译成class文件。对于JavaSE的项目会被编译到项目目录下的bin目录下，对于JavaEE项目会被编译到相应的/WEB-INF/classes文件
夹中 其他文件也会移到到相应的目录下
folder 文件夹

2018 7 11

dtd 文档类型定义(Document Type Definition)是一套为了进行程序间的数据交换而建立的关于标记符的语法规则。文档可根据某种DTD语法规则验证格式是否符合此规则。文档类型定义也可用做保证标准通用标记语言、可扩展标记语言文档格式的合法性，可通过比较文档和文档类型定义文件来检查文档是否符合规范，元素和标签使用是否正确。

MyBatis全局配置文件
	properties 用来引入外部的properties文件
		:resource 用来引入类路径下的资源
		:url		 用来引入网络路径或者磁盘路径下的资源
	
	settings 一个重要的标签 ！
		setting 用来设置每一个设置项
			:name 项名
			:value false/true

	typeAliases 为java类起别名 别名不区分大小写
		typeAlias
			:type 需要起别名的类的全类名 默认别名是类名小写
			:alias 新的别名
		package
			:name 指定包名（当前包以及下面的所有的后代包的每一个类起一个默认的别名 类名小写） 别名有可能冲突报错
			在类使用@Alias注解 为某个类指定新的别名 解决冲突
	typeHandler 映射java的数据类型和sql的数据类型
	
	environments 配置多种环境
		:default 切换环境 
		environment 配置一个具体的环境信息
			transactionManager 事务管理器
				:id 当前环境的唯一标示
				:type 事务管理器的类型 JDBC|MANAGED
					  自定义事务管理器，实现TransactionFactory接口 type指定的全类名
			dataSource  数据源
				:type 数据源类型 UNPOOLED|POOLED|JNDI 不使用连接池 使用连接池 使用JNDI
				自定义数据源 实现DataSourceFactory接口
	
	databaseldProvider 使得MyBatis支持多种不同数据库 
		:type type=DB_VENDOR" 得到数据库厂商的标识
		property
			:name 数据库厂商标识
			:vallue 标识别名
	
	mappers 将sql映射注册到全局配置中
		mapper 注册一个sql映射
			:resource 引用类路径下的sql映射文件
			:url 引用网路路径或者磁盘路径下的sql映射文件
			
			:class 引用接口
				1.有sql映射文件,映射文件必须和接口同名,并且放在与接口同一路径下
				2.没有sql映射文件,所有的sql都是利用注解写在接口上
		package
			:name 包名
MyBatis 映射文件
	MyBatis支持返回 Boolean Integer Long void	
	
	MyBatis接口编程步骤
		1 实体类对应的映射文件
		2 实体类的接口方法
		3 将实体类的映射文件中的 mapper：namespace 与接口类绑定 namespace=接口类名
		4 将实体类的映射文件中的方法id 与 为接口类中的方法名 相同
		
		5用sqlSession的getMapper方法初始化对应的接口类  eg：Objece employeeDao=sqlSession.getMapper(Object.class);
		6调用接口类对应的方法
		
	insert 获取自增主键
		:useGeneratedKeys="true"
		:keyProperty="" 实体类对应的变量名;
		
2018 07 12 MyBatis参数处理
	单个参数 MyBatis不会做任何处理
	多个参数 默认多个参数会被封装成一个map
			 key: param1 param2 ... paramN 或者参数的索引也可以
			 value: 传入的参数值
			 
			 明确指定封装参数的map的key: @Param("id")
			 eg public Employee getEmployeeByIdAndLastName(@Param("id")int id,@Param("lastName")String lastName);
			 
			POJO
				如果多个参数正好是我们业务逻辑的数据模型(存在实体类) 我们就可以直接传入pojo
				#{属性名},去出传入的pojo的属性值
			
			Map
				如果过个参数不是业务模型中的数据,没有对应的pojo 不经常使用,我们可以直接传入map
				#{key} 去出map中的值
				
				如果多个参数不是业务模型中的数据,但是经常使用,推荐来编写一个TO(Transfer Object) 数据传输对象 如 Page{int index,int size}
				
				如果是Collection(List Set)类型或者是数组也会特殊处理
				,也是把传入的list或者数组封装在map中.
				key: Collection (collection) 如果是List还可以使用Key(list) 数组(array)
				eg: public Employee getEmpById(List<Integer> ids);
						取第一个值 #{list[0]}
						
	#{}和${}的区别
		#{} 是以预编译的形式,将参数设置到sql语句中 防止sql注入
		${} 取出的值直接拼装到sql语句中; 会有安全问题
				
		原生jdbc不支持占位符的地方我们就可以使用${}进行取值
		比如 分表,排序 
				
	#{}更丰富的用法
		javaType jdbcType mode(存储过程) numericScale
		resultMap typeHandler jdbcTypeName expression(待完善)
				
		jdbcType通常需要在某种特定的条件下被设置
		在我们数据为null时,有些数据库可能不识别mybatis对null的处理,比如oracle
		jdbcType OTHER 无效的类型 因为mybatis对所有的null都映射的是原生jdbc的OTHER类型
					
		有两种解决办法
		1 #{email,jdbcType=NULL}
		2.全局配置文件 jdbcTypeForNull=NULL
		
		:resultType 如果返回的是一个集合 要写集合中的元素类型 mybatis会自动添加到集合中
		可以填写类型的别名 resultType="map"
		
		返回多条封装一个map Map<Integer,Object> key是这个记录的主键 value是对应的类
		@MapKey("id") //告诉mybatis使用哪个属性作为map的key
		public Map<Integer,Employee> getEmployeeByLastNameLikeReturnMap(String lastName);